<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Literate Programming in HTML</title>

    <style>
      body {
        background-color: #c7edcc;
        max-width: 700px;
        margin-left: auto;
        margin-right: auto;
    }
    </style>

    <!-- literate -->
    <link rel="stylesheet" href="literate.css">
    <script type="text/javascript" src="literate.js"></script>

    <!-- mathjax -->
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>

  <body>
    <h1>Literate Programming in HTML</h1>

    <h2>What Is Literate Programming</h2>
    <p>
      In <a href="http://www.axiom-developer.org/axiom-website/litprog.html">Literate Programming</a>,
      Tim Daly wrote:
      <blockquote cite="http://www.axiom-developer.org/axiom-website/litprog.html">
        The best programming language is English. Everything else is notation.
      </blockquote>
    </p>
    <p>
      Why? he went on to explain:
      <blockquote cite="http://www.axiom-developer.org/axiom-website/litprog.html">
        <p>
          Consider the best possible world. You've been hired at a company and
          join a team that is already working on a program. They hand you a book,
          tell you to go home and read it over the next two weeks. At the end of
          the two weeks you can work on the program as effectively anyone on the
          team. The team has successfully communicated from one human to another.
        </p>
        <p>
          What is in the book? Remember our calculus textbook? It started from
          the ideas like limits and gradually developed the ideas until they could
          be expressed in equations. By the time you got to the equations you
          already understood the concepts. You could look at the equations and see
          why they matched the text. It is the <em>why</em> that is the
          important part. It is the part that our programs are missing.
        </p>
        <p>
          The book you took home uses the same method. You started with the problem
          in chapter 1. Chapter 2 expresses the ideas needed to solve the problem.
          The next few chapters expand on each idea, gradually becoming more specific
          until the idea is reduced to code. By the time you get to the code it
          should be perfectly clear what the code should look like. Any part of
          the code you don't understand means that the book needs some additional words.
        </p>
      </blockquote>
      Literate programming is like when you are explaining your code to a colleague.
      You have to declare what you were thinking when you wrote the code, step by
      step, piece by piece. You are telling the whole story: which step is essential,
      why the order must be so, or what is this used for. All materials are organized
      in a structure that makes sense to you (not to the compiler).
    </p>

    <p>
      Technically, literate programming has two components: <strong>weave</strong>
      and <strong>tangle</strong>. By weaving, the source code is converted to
      printable document, such as PDF or HTML. By tangling, the codes involved
      in the document are extracted and organized in order.
    </p>
    <p>
      The basic building blocks are chunks and chunk references.
      
      A <strong>chunk</strong> is a piece of code assigned with a name, called
      <strong>chunk name</strong>. And a <strong>chunk reference</strong> refers
      to a chunk by its name.

      So, for example, we can define a chunk named <code>hello.c</code>:

      <div class="chunk" name="hello.c">
        <span class="chunkref">include</span>
        int main() {
          <span class="chunkref">say hello</span>
          return 0;
        }
      </div>
      where the chunk references <span class="chunkref">include</span> and
      <span class="chunkref">say hello</span> are defined elsewhere. As an
      example, <span class="chunk" name="include">#include &lt;stdio.h&gt;</span>
      and <span class="chunk" name="say hello">printf("Hello, world!\n");</span>

      Then, by tangling, code are extracted and organized in order:

      <pre><code>
        #include &lt;stdio.h&gt;
        int main() {
          printf("Hello, world!\n");
          return 0;
        }
      </code></pre>
    </p>

    <h2>Why Using HTML</h2>
    <p>
      The main reason is that the HTML file can be displayed directly in a browser.
      So, there is no need to weave.

      Yet another benefit is that HTML provides a standard for markup languages.
      Any other markup formats (such as markdown) can be safely converted to HTML.
    </p>
    <p>
      Comparing with \(\TeX\), HTML is much modern and widely used. It can be
      displayed on any device including mobile phones.

      With the aid of JavaScript, users can interactive with HTML document.
    </p>

    <h2>Chunk in HTML</h2>

    <h3>HTML Elements for Chunks</h3>
    <p>
      As usual, we use the "class" attribute to indicate chunk and chunk reference.
      Thus, block chunk is represented by <code>div</code> element with class "chunk"
      and a name attribute. <em>Chunk name shall be plain text.</em> For example:
      <pre><code>
        &lt;div class="chunk" name="hello.c"&gt;

          ...code block...
        
        &lt;/div&gt;
      </code></pre>
      And inline chunk is represented by <code>span</code> element with class "chunk"
      and a name attribute. For example:
      <pre><code>
        &lt;span class="chunk" name="say hello"&gt; ...one line code... &lt;/span&gt;
      </code></pre>
      Chunk reference, which is always inline, is represented by <code>span</code>
      element with class "chunkref". The referred chunk name locates in the content
      of the <code>span</code> element. Thus,
      <pre><code>
        &lt;span class="chunkref"&gt;say hello&lt;/span&gt;
      </code></pre>
    </p>

    <h3 id="shareing-chunk-name">Sharing Chunk Name</h3>
    <p>
      Different chunks may share the same name. For example:
      <pre><code>
        &lt;div class="chunk" name="include"&gt;
          #include &lt;stdio.h&gt;
        &lt;/div&gt;
      </code></pre>
      and then after some explanation,
      <pre><code>
        &lt;div class="chunk" name="include"&gt;
          #include &lt;math.h&gt;
        &lt;/div&gt;
      </code></pre>
      While tangling, chunks with the same name are stacked in due order.
      Thus, the previous example is equivalent to:
      <pre><code>
        &lt;div class="chunk" name="include"&gt;
          #include &lt;stdio.h&gt;
          #include &lt;math.h&gt;
        &lt;/div&gt;
      </code></pre>
    </p>

    <h2>Weaving</h2>
    <p>
      Chunks are woven to display in browser. We use JavaScript to transcript
      the HTML elements of chunks and chunk references into the those that are
      more suitable for display and cooperating with CSS.
    </p>

    <h3>Weaving Chunk Reference</h3>
    <p>
      We first deal with chunk reference. Recall that chunk reference has the format
      <code>&lt;span class="chunkref"&gt;chunk name&lt;/span&gt;</code>.
      We are to transcript it into ⟨chunk name⟩.
    </p>
    <p>
      To do this, we replace the <code>innerHTML</code> of the <code>span</code>
      element with "⟨chunk name⟩".
      But, this will modify the original HTML, such that, at the time of tangling,
      we cannot tangle from the original code. For dealing with this problem, we
      shall store the original in a new <code>span</code> element with the class
      "unwoven" and set it as hidden.
      So, the code splits into two parts:
      <div class="chunk" name="weave chunk reference">
        function weaveChunkRef(chunkRef) {
          <span class="chunkref">create unwoven span for weaving chunk reference</span>
          <span class="chunkref">replace innerHTML for weaving chunk reference</span>
        }
      </div>
      wherein,
      <div class="chunk" name="create unwoven span for weaving chunk reference">
        /* Create unwoven span */
        var unwoven = document.createElement("span");
        unwoven.setAttribute("class", "unwoven");
        unwoven.setAttribute("hidden", true);
        unwoven.innerHTML = chunkRef.innerHTML;
      </div>
      Now, we clean up the <code>chunkRef</code> element and add "⟨chunk name⟩" and
      the unwoven <code>span</code> to it. But, before cleaning, we shall store the
      chunk name, which is the <code>chunkRef.innerHTML</code>, in a new variable.
      <div class="chunk" name="replace innerHTML for weaving chunk reference">
        /* Replace HTML */
        var chunkName = chunkRef.innerHTML;
        chunkRef.innerHTML = null;
        chunkRef.appendChild(document.createTextNode(`⟨${chunkName}⟩`));
        chunkRef.appendChild(unwoven);
      </div>
    </p>

    <h3>Unweaving</h3>
    <p>
      With the unwoven span, to unweave a chunk reference or a chunk in later,
      all we need to do is iterating over the children nodes and find out the
      element with class "unwoven". (If not found, throw an error.)
      <div class="chunk" name="unweave">
        function unweave(elem) {
          for (var i = 0; i < elem.children.length; i++) {
            var child = elem.children[i];
            if (child.getAttribute("class") == "unwoven") {
              return child;
            }
          }
          throw new Error("[unweave] no unwoven span found in element: " + elem.innerHTML);
        }
      </div>
    </p>

    <h3>Weaving Inline Chunk</h3>
    <p>
      Then, consider inline chunk. Inline chunk is displayed in the format
      <pre><code>
        &lt;span class="inline-chunk-head"&gt;⟨chunk name⟩≡&lt;/span&gt;
        &lt;code&gt;... one line code ...&lt;/code&gt;
      </code></pre>
      within the original <code>&lt;span class="chunk"&gt;</code> element.
      We add a <code>span</code> element for the head:
      <div class="chunk" name="create head for inline chunk">
        /* Create chunk head span */
        var chunkHead = document.createElement("span");
        chunkHead.setAttribute("class", "inline-chunk-head");
        chunkHead.innerHTML = `⟨${chunk.getAttribute("name")}⟩≡`;
      </div>
      And the one line code is wrapped in a <code>code</code> element:
      <div class="chunk" name="create code for inline chunk">
        /* Create code */
        var code = document.createElement("code");
        code.innerHTML = chunk.innerHTML;
      </div>
      Again, we shall append an unwoven span to the inline chunk. So, we simply
      follow the code in <span class="chunkref">weave chunk reference</span>,
      with a little adaptation.
      <div class="chunk" name="weave inline chunk">
        function weaveInlineChunk(chunk) {
          /* Create unwoven span */
          var unwoven = document.createElement("span");
          unwoven.setAttribute("class", "unwoven");
          unwoven.setAttribute("hidden", true);
          unwoven.innerHTML = chunk.innerHTML;

          <span class="chunkref">create head for inline chunk</span>

          <span class="chunkref">create code for inline chunk</span>

          /* Replace HTML */
          chunk.innerHTML = null;
          chunk.appendChild(chunkHead);
          chunk.appendChild(code);
          chunk.appendChild(unwoven);
        }
      </div>
    </p>

    <h3>Weaving Block Chunk</h3>
    <p>
      Finally, consider block chunk. Almost the same as inline chunk, block chunk
      should be displayed in the format
      <pre><code>
        &lt;span class="block-chunk-head"&gt;⟨chunk name⟩≡&lt;/span&gt;
        &lt;pre&gt;&lt;code&gt;
          ... code block ...
        &lt;/code&gt;&lt;/pre&gt;
      </code></pre>
      within the original <code>&lt;div class="chunk"&gt;</code> element.
      But, we add a link to the head, clicking which will tangle the chunk.
      Thus, the head span turns into
      <pre><code>
        ⟨&lt;a onclick="tangle(chunkName)"&gt;chunkName&lt;/a&gt;⟩≡
      </code></pre>
      For the tangle link, we have:
      <div class="chunk" name="chunk head span for block chunk">
        /* Create chunk head span */
        var tangleLink = document.createElement("a");
        var chunkName = chunk.getAttribute("name");
        tangleLink.setAttribute("href", "javascript:void(0)");
        tangleLink.setAttribute("onclick", `tangle('${chunkName}')`);
        tangleLink.innerHTML = chunkName;
      </div>
      Then, we create the head and append everything in order.
      <div class="chunk" name="chunk head span for block chunk">
        var chunkHead = document.createElement("span");
        chunkHead.setAttribute("class", "block-chunk-head");
        chunkHead.appendChild(document.createTextNode("⟨"));
        chunkHead.appendChild(tangleLink);
        chunkHead.appendChild(document.createTextNode("⟩≡"));
      </div>
      The unwoven now becomes a <code>div</code> element. So, the code for weaving
      block chunk simply an adaptation of <span class="chunkref">weave inline chunk</span>.
      <div class="chunk" name="weave block chunk">
        function weaveBlockChunk(chunk) {
          /* Create unwoven span */
          var unwoven = document.createElement("div");
          unwoven.setAttribute("class", "unwoven");
          unwoven.setAttribute("hidden", true);
          unwoven.innerHTML = chunk.innerHTML;

          <span class="chunkref">chunk head span for block chunk</span>

          /* Create pre */
          var pre = document.createElement("pre");
          var code = document.createElement("code");
          code.innerHTML = chunk.innerHTML;
          pre.appendChild(code);

          /* Replace HTML */
          chunk.innerHTML = null;
          chunk.appendChild(chunkHead);
          chunk.appendChild(pre);
          chunk.appendChild(unwoven);
        }
      </div> 
    </p>

    <h3>Regularize Code Block</h3>
    <p>
      A widely known problem is the whitespace before the "code block". Browser
      will display these whitespace, which is not what we intend. To solve this,
      we have to regularize the code block wrapped by a <code>pre</code> element.
      For example, code block like this:
      <pre><code>
        &lt;pre&gt;
          if (i = 0) {
            i++;
          }
        &lt;/pre&gt;
      </code></pre>
      has the raw text (<code>\n</code> for newline and <code>\s</code> for whitespace):
      <pre><code>
        &lt;pre&gt;&lt;code&gt;<strong>\n\s\s\s\s\s\s</strong>if<strong>\s</strong>(i<strong>\s</strong>=<strong>\s</strong>0)<strong>\s</strong>{<strong>\n\s\s\s\s\s\s\s\s</strong>i++;<strong>\n\s\s\s\s\s\s</strong>}<strong>\n\s\s\s\s</strong>&lt;/code&gt;&lt;/pre&gt;
      </code></pre>
      There are six extra whitespace in front of each line, and four whitespace
      after the while code block. There is also an extra newline in front of the
      code block.
    </p>
    <p>
      We are to remove these extra characters.      
      <div class="chunk" name="regularize code block">
        function regularizeCodeBlock(text) {
          <span class="chunkref">define regularization</span>
        }
      </div>
      We need to figure out the indentation (the six extra whitespace in front
      of each line). We use the whitespace in front of the first line of code
      as the indentation of the whole code block.

      We also need to count the number of whitespace in front of each line
      (<code>whitespaceCount</code>) and subtract indentation from it.
      Consider the line <code>i++;</code> in the previous example, it has
      <code>whitespaceCount = 8</code> and <code>indentation = 6</code>, so this
      line is indented by 2 whitespace (<code>whitespaceCount - indentation</code>).
      In addition, a flag for the state of counting is found helpful.
      <div class="chunk" name="define regularization">
        var result = "";
        var indentation = 0;
        var whitespaceCount = 0;
        var counting = false;
        for (var i = 0; i < text.length; i++) {
          <span class="chunkref">walk through text for regularization</span>
        }
      </div>

      Let us go through the text. When we have not meet any code character, the
      <code>result</code> is empty. In this case, we omit the newlines. 
      If we have not encountered any character of the code block, but whitespace,
      indicating that this maybe the first line of code, we increase <code>indentation</code>.
      <div class="chunk" name="walk through text for regularization">
        if ((result == "") && (text[i] == ' ')) {
          indentation++;
        }
      </div>
      But, it maybe an empty line, a line with only whitespace. So, after a newline
      break, we reset the <code>indentation</code>, expecting for the first line of
      code.
      <div class="chunk" name="walk through text for regularization">
        else if ((result == "") && (text[i] == '\n')) {
          indentation = 0;
        }
      </div>
      Now we have considered the case when <code>result</code> is empty, and only
      encountering the newline and whitespace. Now, if a code character appears
      we append it to <code>result</code>.
      <div class="chunk" name="walk through text for regularization">
        else if (result == "") {
          result += text[i];
        }
      </div>
      Now, <code>result</code> is not empty any more, and thus <code>indentation</code>
      is fixed.
      We continue appending new code character to <code>result</code> until we meet a
      newline. In this case, we set <code>counting</code> to <code>true</code>, and
      start counting whitespace. The counting ends when we encounter a code character.
      In the end, do not forget to append this newline character to <code>result</code>.
      <div class="chunk" name="walk through text for regularization">
        else if (text[i] == '\n') {
          whitespaceCount = 0;
          counting = true;
          result += text[i];
        }
      </div>
      Then, we continue counting whitespace until we meet a code character.
      <div class="chunk" name="walk through text for regularization">
        else if ((counting == true) && (text[i] == ' ')) {
          whitespaceCount++;
        }
      </div>
      When we meet a character which is neither newline or whitespace, we find a
      code character. Then, we stop counting, and append the correct number of
      whitespace in front of the line of code.
      (We also check that <code>whitespaceCount</code> is greater than <code>indentation</code>,
      as it should be.)
      In the end, we append the code character to <code>result</code>.
      <div class="chunk" name="walk through text for regularization">
        else if (counting == true) {
          counting = false;
          if (whitespaceCount < indentation) throw new Error("[regularizeCodeBlock] indentation error");
          for (var j = 0; j < (whitespaceCount - indentation); j++) result += " ";
          result += text[i];
        }
      </div>
      We have dealt with the whitespace in front of a line of code. Before going
      into the next line, all we need to do is appending new code characters to
      <code>result</code>.
      <div class="chunk" name="walk through text for regularization">
        else {
          result += text[i];
        }
      </div>
      Up to now, we have solved the problem in front of each line of code. The
      previous example is regularized to
      <pre><code>
        &lt;pre&gt;&lt;code&gt;<strong></strong>if<strong>\s</strong>(i<strong>\s</strong>=<strong>\s</strong>0)<strong>\s</strong>{<strong>\n\s\s</strong>i++;<strong>\n</strong>}<strong>\n</strong>&lt;/code&gt;&lt;/pre&gt;
      </code></pre>
      Notice that there is still an extra newline character in the end of the code
      block. And there may be multiple ending newline characters in other examples.
      To remove it, we iterate the result in backward direction and remove newlines
      until encountering another character.
      <div class="chunk" name="define regularization">
        for (var i = (result.length - 1); i >= 0; i--) {
          if (result[i] == '\n') {
            result = result.substring(0, i);
          }
          else {
            break;
          }
        }
      </div>
      Now, it becomes what we intend to write. It is safely to return the result.
      <div class="chunk" name="define regularization">
        return result;
      </div>
    <p>
      We have implemented the function for regularizing code in block chunk. Other
      code blocks in the HTML file wrapped in <code>&lt;pre&gt;&lt;code&gt;</code>
      element also need regularization. So, we regularize both of them; the order
      is irrelevant.
      <div class="chunk" name="regularize all">
        function regularize() {
          <span class="chunkref">regularize block chunk</span>
          <span class="chunkref">regularize code in pre</span>
        }
      </div>
      wherein
      <div class="chunk" name="regularize block chunk">
        var divs = document.getElementsByTagName("div");
        for (var i = 0; i < divs.length; i++) {
          if (divs[i].getAttribute("class") == "chunk") {
            divs[i].innerHTML = regularizeCodeBlock(divs[i].innerHTML);
          }
        }
      </div>
      and
      <div class="chunk" name="regularize code in pre">
        var pres = document.getElementsByTagName("pre");
        for (var i = 0; i < pres.length; i++) {
          var codes = pres[i].getElementsByTagName("code");
          for (var j = 0; j < codes.length; j++) {
            codes[j].innerHTML = regularizeCodeBlock(codes[j].innerHTML);
          }
        }
      </div>
    </p>

    <h3>Weave All</h3>
    Now, we have had the all the functions for weaving. The order of weaving
    chunk references and chunks is irrelevant. So,
    <div class="chunk" name="weave all">
      function weave() {
        <span class="chunkref">weave chunk references</span>
        <span class="chunkref">weave chunks</span>
      }
    </div>
    Weaving chunk references is straight forward. We use a stupid loop to
    implement it.
    <div class="chunk" name="weave chunk references">
      /* Weave chunk references */
      var chunkRefs = document.getElementsByClassName("chunkref");
      for (var i = 0; i < chunkRefs.length; i++) {
        weaveChunkRef(chunkRefs[i]);
      }
    </div>
    Weaving chunks is a little more complicated, since chunks can be inline
    (a <code>span</code>) or block (a <code>div</code>).
    <div class="chunk" name="weave chunks">
      /* Weave chunks */
      var chunks = document.getElementsByClassName("chunk");
      for (var i = 0; i < chunks.length; i++) {
        var chunk = chunks[i];
        if (chunk.tagName == "SPAN") {
          weaveInlineChunk(chunk);
        }
        else if (chunk.tagName == "DIV") {
          weaveBlockChunk(chunk);
        }
        else {
          throw new Error("[weave] unknown chunk type: " + chunk.tagName);
        }
      }
    </div>

    <h2>Tangling</h2>

    <h3>Tangling Each Chunk</h3>
    <p>
      The main process of tangling is implemented by a function <code>_tangle</code>,
      which accepts a string <code>chunkName</code> and returns a string for the
      tangled code:
      <div class="chunk" name="_tangle">
        function _tangle(chunkName) {
          var code = "";
          <span class="chunkref">define _tangle</span>
          return code;
        }
      </div>
    </p>
    <p>
      To define <code>_tangle</code>, we first collect all chunks that have the name
      <code>chunkName</code>.
      As stated in a <a href="#share-chunk-name">previous section</a>, there can be
      multiple chunks with the same name.
      <div class="chunk" name="define _tangle">
        var chunks = document.getElementsByName(chunkName);
        for (var i = 0; i < chunks.length; i++) {
          if (chunks[i].getAttribute("class") != "chunk") continue;
          <span class="chunkref">tangle each chunk</span>
        }
      </div>
      For each chunk we find, we first unweave it. Since we will replace chunk
      references in it with the corresponding tangled code, that is, we will
      manipulate it in-place, we need to make a copy of it, a deep copy.
      <div class="chunk" name="tangle each chunk">
        var unwoven = unweave(chunks[i]).cloneNode(true);
      </div>
      To find a chunk reference and replace it with the code in the referred chunk,
      we must take care. Replacing the chunk reference with the corresponding code
      will modify the children of the unwoven chunk, so using for-loop like
      <pre><code>
        for (int i = 0; i < unwoven.getElementsByClass("chunkref").length; i++)
      </code></pre>
      leads to mistakes. Instead, we employ a function that get the first child of
      the unwoven chunk that represents a chunk reference. After replacement, the
      first child of chunk reference will automatically turns to the next.
      <div class="chunk" name="tangle each chunk">
        /* Deal with chunk references */
        var chunkRef = getFirstChildByClass(unwoven, "chunkref");
        while (chunkRef != undefined) {
          <span class="chunkref">replace chunk reference</span>
          chunkRef = getFirstChildByClass(unwoven, "chunkref");
        }
      </div>
      After replacing all chunk references within the unwoven chunk, we append it
      to the <code>code</code> string. Besides, we also add a newline character
      between different chunks that share the same chunk name.
      <div class="chunk" name="tangle each chunk">
        code += unwoven.innerHTML;
        if (i < chunks.length - 1) code += "\n";
      </div>
      The implementation of <code>getFirstChildByClass</code> is straight forward.
      <div class="chunk" name="get first child by class">
        function getFirstChildByClass(node, className) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            if (child.getAttribute("class") == className) {
              return child;
            }
          }
          return undefined;
        }
      </div>
    </p>
    <h3>Replacing Chunk Reference</h3>
    <p>
      For the replacement, we first get the referred chunk name. To distinguish
      the input <code>chunkName</code>, we call it <code>subChunkName</code>.
      <div class="chunk" name="replace chunk reference">
        var subChunkName = unweave(chunkRef).innerHTML;
      </div>
      Then, we get the tangled code by <strong>recursion!</strong>
      (Again, we call it <code>subCode</code>).
      <div class="chunk" name="replace chunk reference">
        var subCode = _tangle(subChunkName);
      </div>
      Very simple, isn't it? Remark that, if the referred chunk is a block chunk,
      which involve multiple lines, then we have to indent the second, third, ...
      lines of the <code>subCode</code> so that they share the same indentation.
      (The first line has correct indentation, since it is written by you.) So,
      for a block chunk, we have to determine the indentation and add it to each
      line.
      <div class="chunk" name="replace chunk reference">
        /* Block chunk needs indentation */
        if (chunks[i].tagName == "DIV") {
          var indentation = getIndentation(chunkRef);
          subCode = indent(subCode, indentation);
        }
      </div>
      Everything is ready. Now we replace the chunk reference with the tangled
      <code>subCode</code>. Since <code>replaceWith</code> method requires an
      element (node) as input, we shall wrap the string <code>subCode</code> by
      a <code>span</code> element.
      <div class="chunk" name="replace chunk reference">
        var subCodeNode = document.createElement("span");
        subCodeNode.innerHTML = subCode;
        chunkRef.replaceWith(subCodeNode);
      </div>
    </p>

    <h3>Display in Browser</h3>
    <p>
      By clicking the "⟨chunk name⟩≡", function <code>tangle(chunkName)</code> is
      triggered. We popup a new window to show the tangled code, thus:
      <div class="chunk" name="tangle">
        function tangle(chunkName) {
          var code = _tangle(chunkName);
          <span class="chunkref">create HTML for the tangled code</span>
          <span class="chunkref">display HTML in a new window</span>
        }
      </div>
      We use the following HTML to display the tangled code:
      <div class="chunk" name="create HTML for the tangled code">
        html = `&lt;!doctype html&gt;&lt;html&gt;` +
               `&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;${chunkName}&lt;/title&gt;` +
               `&lt;style&gt;body { background-color: #c7edcc; }&lt;/style&gt;&lt;/head&gt;` +
               `&lt;body&gt;&lt;pre&gt;&lt;code&gt;${code}&lt;/code&gt;&lt;/pre&gt;&lt;/body&gt;` +
               `&lt;/html&gt;`;
      </div>
      This HTML is to be displayed in a new window:
      <div class="chunk" name="display HTML in a new window">
        var win = window.open('about:blank', '_blank');
        win.document.write(html);
        win.document.close();
      </div>
    </p>

    <h3>Utility Functions</h3>
    <p>
      Before ending this section, we have to show how the functions <code>getIndentation</code>
      and <code>indent</code> are implemented. They turns out to be simple.
      The <code>getIndentation</code> function just returns the indentation
      of the first line of the code. For example, in the following code,
      <pre><code>
        void main() {
          &lt;span class="chunkref"&gt;say hello&lt;/span&gt;;
        }
      </code></pre>
      the chunk reference (the second line) has indentation 2. We have to figure
      it out. To do so, we first extract all the string before the chunk reference,
      which, in this example, is
      <pre><code>
        void main() {
          (end here)
      </code></pre>
      This is done by the following function (following <a href="https://stackoverflow.com/a/72545166/1218716">this answer</a>):
      <div class="chunk" name="get text before">
        function getTextBefore(node) {
          var rangeBefore = document.createRange();
          rangeBefore.setStart(node.parentNode.firstChild, 0);
          rangeBefore.setEndBefore(node);
          return rangeBefore.toString();
        }
      </div>
      Then, directly, we count how many whitespace between the front of the chunk
      chunk reference and beginning of the line.
      <div class="chunk" name="get indentation">
        function getIndentation(chunkRef) {
          var textBefore = getTextBefore(chunkRef);
          var indentation = 0;
          for (var i = textBefore.length - 1; i >= 0; i--) {
            if (textBefore[i] == ' ') {
              indentation++;
            } else {
              break;
            }
          }
          return indentation;
        }
      </div>
      The <code>indent</code> function is also straight forward. We simply prepend
      <code>indentation</code> many whitespace before each line.
      <div class="chunk" name="indent">
        function indent(text, indentation) {
          var result = "";
          for (var i = 0; i < text.length; i++) {
            result += text[i];
            if (text[i] == '\n') {
              for (var j = 0; j < indentation; j++) result += ' ';
            }
          }
          return result;
        }
      </div>
    </p>

    <h2>Packaging</h2>

    <p>
      In the end of our literate programming journey, we put all these into one
      JavaScript file, called <code>literate.js</code>.
      <div class="chunk" name="literate.js">
        /* Literate Programming in HTML */
  
        <span class="chunkref">weave chunk reference</span>
  
        <span class="chunkref">unweave</span>
  
        <span class="chunkref">weave inline chunk</span>
  
        <span class="chunkref">weave block chunk</span>
  
        <span class="chunkref">regularize code block</span>
  
        <span class="chunkref">regularize all</span>
  
        <span class="chunkref">weave all</span>
  
        <span class="chunkref">_tangle</span>

        <span class="chunkref">tangle</span>
  
        <span class="chunkref">get first child by class</span>
  
        <span class="chunkref">get text before</span>
  
        <span class="chunkref">get indentation</span>
  
        <span class="chunkref">indent</span>
      </div>
  
      On loading, we first call <code>regularize</code> for regularizing the code
      blocks. And then calling <code>weave</code> for displaying the chunks and
      chunk references in browser. The order of these two functions are crucial,
      We shall first regularize the code for any modification (such as weaving).
      So, <code>regularize</code> shall always be called in the first place.
      <div class="chunk" name="literate.js">
        onload = () => {
          regularize();
          weave();
        }
      </div>
      Up to now, we have completed the JavaScript code for literate programming.
    </p>
   
    <h2>Style</h2>

    <p>
      We use CSS to style the chunks and chunk references.
    </p>

    <h3>Code Block</h3>
    <p>
      We put code block into a block, of course. The block is wrapped by a dashed
      grey border. We also adjust the position of the code, to move it toward the
      center of the border.
      <div class="chunk" name="code in pre style">
        pre code {
          display: block;
          border-style: dashed;
          border-color: grey;
          border-width: medium;
          overflow-x: auto;
          margin: 1em;
          padding-left: 3em;
          padding-top: 1em;
          padding-bottom: 1em;
        }
      </div>
    </p>

    <h3>Chunk</h3>

    <p>
      For each chunk, we add a narrow margin to make it appear a little isolated
      from the content.
      <div class="chunk" name="chunk style">
        div.chunk {
          margin-top: 1em;
          margin-bottom: 1em;
        }
      </div>
    </p>

    <h4>Block Chunk</h4>
    <p>
      For block chunk, we make the head bold, indicating a definition (we always
      make something bold when it is defined).
      <div class="chunk" name="block chunk head style">
        .block-chunk-head {
          font-weight: bold;
        }
      </div>
      We use a dashed border instead of a underline for hyperlink, which triggers
      <code>tangle</code>, for making it pretty.
      <div class="chunk" name="block chunk head hyperlink style">
        .block-chunk-head a {
          border: 0.1em;
          border-style: dashed;
          text-decoration: none;
          padding: 0.1em 0.1em;
          margin: 0.1em;
          color: black;
        }
      </div>
    </p>

    <h3>Inline Chunk</h3>
    <p>
      For inline chunk, we simply make the head bold, indicating a definition,
      and add a very narrow margin to isolate it from the content.
      <div class="chunk" name="inline chunk style">
        .inline-chunk-head {
          font-weight: bold;
          margin-left: 0.1em;
          margin-right: 0.1em;
        }
      </div>
    </p>

    <h3>CSS File</h3>
    <p>
      Put all these together, we get the following CSS file <code>literate.css</code>.
      <div class="chunk" name="literate.css">
        <span class="chunkref">code in pre style</span>

        <span class="chunkref">chunk style</span>

        <span class="chunkref">block chunk head style</span>

        <span class="chunkref">block chunk head hyperlink style</span>

        <span class="chunkref">inline chunk style</span>
      </div>
    </p>

  </body>
</html>
