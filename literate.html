<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Literate Programming in HTML</title>

    <style>
      body {
        background-color: #c7edcc;
    }
    </style>

    <!-- literate -->
    <link rel="stylesheet" href="literate.css">
    <script type="text/javascript" src="literate.js"></script>

    <!-- mathjax -->
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>

  <body>
    <h1>Literate Programming in HTML</h1>

    <h2>What Is Literate Programming</h2>
    <p>
      In <a href="http://www.axiom-developer.org/axiom-website/litprog.html">Literate Programming</a>,
      Tim Daly wrote:
      <blockquote cite="http://www.axiom-developer.org/axiom-website/litprog.html">
        The best programming language is English. Everything else is notation.
      </blockquote>
    </p>
    <p>
      Why? he went on to explain:
      <blockquote cite="http://www.axiom-developer.org/axiom-website/litprog.html">
        <p>
          Consider the best possible world. You've been hired at a company and
          join a team that is already working on a program. They hand you a book,
          tell you to go home and read it over the next two weeks. At the end of
          the two weeks you can work on the program as effectively anyone on the
          team. The team has successfully communicated from one human to another.
        </p>
        <p>
          What is in the book? Remember our calculus textbook? It started from
          the ideas like limits and gradually developed the ideas until they could
          be expressed in equations. By the time you got to the equations you
          already understood the concepts. You could look at the equations and see
          why they matched the text. It is the <em>why</em> that is the
          important part. It is the part that our programs are missing.
        </p>
        <p>
          The book you took home uses the same method. You started with the problem
          in chapter 1. Chapter 2 expresses the ideas needed to solve the problem.
          The next few chapters expand on each idea, gradually becoming more specific
          until the idea is reduced to code. By the time you get to the code it
          should be perfectly clear what the code should look like. Any part of
          the code you don't understand means that the book needs some additional words.
        </p>
      </blockquote>
      TODO
    </p>

    <p>
      Briefly, literate programming has two components: <strong>weave</strong>
      and <strong>tangle</strong>. By weaving, the source code is converted to
      printable document, such as PDF or HTML. By tangling, the codes involved
      in the document are extracted and organized in order.
    </p>
    <p>
      The basic building blocks are chunks and chunk references.
      
      A <strong>chunk</strong> is a piece of code assigned with a name, called
      <strong>chunk name</strong>. And a <strong>chunk reference</strong> refers
      to a chunk by its name.

      So, for example, we can define a chunk named <code>hello.c</code>:

      <div class="chunk" name="hello.c">
        <span class="chunkref">include</span>
        int main() {
          <span class="chunkref">say hello</span>
          return 0;
        }
      </div>

      where the chunk references <span class="chunkref">include</span> and
      <span class="chunkref">say hello</span> are defined elsewhere. As an
      example, <span class="chunk" name="include">#include &lt;stdio.h&gt;</span>
      and <span class="chunk" name="say hello">printf("Hello, world!\n");</span>

      Then, by tangling, code are extracted and organized in order:

      <pre><code>
        #include &lt;stdio.h&gt;
        int main() {
          printf("Hello, world!\n");
          return 0;
        }
      </code></pre>
    </p>

    <h2>Why Using HTML</h2>
    <p>
      The main reason is that the HTML file can be displayed directly in a browser.
      So, there is no need to weave.

      Yet another benefit is that HTML provides a standard for markup languages.
      Any other markup formats (such as markdown) can be safely converted to HTML.
    </p>
    <p>
      Comparing with \(\TeX\), HTML is much modern and widely used. It can be
      displayed on any device including mobile phones.

      With the aid of JavaScript, users can interactive with HTML document.
    </p>

    <h2>Chunk in HTML</h2>

    <h3>HTML Elements for Chunks</h3>
    <p>
      As usual, we use the "class" attribute to indicate chunk and chunk reference.
      Thus, block chunk is represented by <code>div</code> element with class "chunk"
      and a name attribute. <em>Chunk name shall be plain text.</em> For example:
      <pre><code>
        &lt;div class="chunk" name="hello.c"&gt;

          ...code block...
        
        &lt;/div&gt;
      </code></pre>
      If the chunk is to be tangled, then we add an attribute <code>export</code>,
      whose value is irrelevant.
      And inline chunk is represented by <code>span</code> element with class "chunk"
      and a name attribute. For example:
      <pre><code>
        &lt;span class="chunk" name="say hello"&gt; ...one line code... &lt;/span&gt;
      </code></pre>
      Chunk reference, which is always inline, is represented by <code>span</code>
      element with class "chunkref". The refered chunk name locates in the content
      of the <code>span</code> element. Thus,
      <pre><code>
        &lt;span class="chunkref"&gt;say hello&lt;/span&gt;
      </code></pre>
    </p>

    <h3 id="shareing-chunk-name">Sharing Chunk Name</h3>
    <p>
      Different chunks may share the same name. For example:
      <pre><code>
        &lt;div class="chunk" name="include"&gt;
          #include &lt;stdio.h&gt;
        &lt;/div&gt;
      </code></pre>
      and then after some explanation,
      <pre><code>
        &lt;div class="chunk" name="include"&gt;
          #include &lt;math.h&gt;
        &lt;/div&gt;
      </code></pre>
      While tangling, chunks with the same name are stacked in due order.
      Thus, the previous example is equivalent to:
      <pre><code>
        &lt;div class="chunk" name="include"&gt;
          #include &lt;stdio.h&gt;
          #include &lt;math.h&gt;
        &lt;/div&gt;
      </code></pre>
      To export the chunks with the same name, we set attribute <code>export</code>
      at least to the first chunk.
    </p>

    <h2>Weaving</h2>
    <p>
      Chunks are woven to display in browser. We use JavaScript to transcript
      the HTML elements of chunks and chunk references into the those that are
      more suitable for display and coorporating with CSS.
    </p>

    <h3>Weaving Chunk Reference</h3>
    <p>
      We first deal with chunk reference. Recall that chunk reference has the format
      <code>&lt;span class="chunkref"&gt;chunk name&lt;/span&gt;</code>.
      We are to transcript it into ⟨chunk name⟩.
    </p>
    <p>
      To do this, we replace the <code>innerHTML</code> of the <code>span</code>
      element with "⟨chunk name⟩".
      But, this will modify the original HTML, such that, at the time of tangling,
      we cannot tangle from the original code. For dealing with this problem, we
      shall store the original in a new <code>span</code> element with the class
      "unwoven" and set it as hidden.
      So, the code splits into two parts:
      <div class="chunk" name="weave chunk reference" export>
        function weaveChunkRef(chunkRef) {
          <span class="chunkref">create unwoven span for weaving chunk reference</span>
          <span class="chunkref">replace innerHTML for weaving chunk reference</span>
        }
      </div>
      wherein,
      <div class="chunk" name="create unwoven span for weaving chunk reference">
        /* Create unwoven span */
        var unwoven = document.createElement("span");
        unwoven.setAttribute("class", "unwoven");
        unwoven.setAttribute("hidden", true);
        unwoven.innerHTML = chunkRef.innerHTML;
      </div>
      Now, we clean up the <code>chunkRef</code> element and add "⟨chunk name⟩" and
      the unwoven <code>span</code> to it. But, before cleaning, we shall store the
      chunk name, which is the <code>chunkRef.innerHTML</code>, in a new variable.
      <div class="chunk" name="replace innerHTML for weaving chunk reference">
        /* Replace HTML */
        var chunkName = chunkRef.innerHTML;
        chunkRef.innerHTML = null;
        chunkRef.appendChild(document.createTextNode(`⟨${chunkName}⟩`));
        chunkRef.appendChild(unwoven);
      </div>
    </p>

    <h3>Unweaving</h3>
    <p>
      With the unwoven span, to unweave a chunk reference or a chunk in later,
      all we need to do is iterating over the children nodes and find out the
      element with class "unwoven". (If not found, throw an error.)
      <div class="chunk" name="unwoven" export>
        function unweave(elem) {
          for (var i = 0; i < elem.children.length; i++) {
            var child = elem.children[i];
            if (child.getAttribute("class") == "unwoven") {
              return child.innerHTML;
            }
          }
          throw new Error("[unweave] no unwoven span found in element: " + elem.innerHTML);
        }
      </div>
    </p>

    <h3>Weaving Inline Chunk</h3>
    <p>
      Then, consider inline chunk. Inline chunk is displayed in the format
      <pre><code>
        &lt;span class="inline-chunk-head"&gt;⟨chunk name⟩≡&lt;/span&gt;
        &lt;code&gt;... one line code ...&lt;/code&gt;
      </code></pre>
      within the original <code>&lt;span class="chunk"&gt;</code> element.
      We add a <code>span</code> element for the head:
      <div class="chunk" name="create head for inline chunk">
        /* Create chunk head span */
        var chunkHead = document.createElement("span");
        chunkHead.setAttribute("class", "inline-chunk-head");
        chunkHead.innerHTML = `⟨${chunk.getAttribute("name")}⟩≡`;
      </div>
      And the one line code is wrapped in a <code>code</code> element:
      <div class="chunk" name="create code for inline chunk">
        /* Create code */
        var code = document.createElement("code");
        code.innerHTML = chunk.innerHTML;
      </div>
      Again, we shall append an unwoven span to the inline chunk. So, we simply
      follow the code in <span class="chunkref">weave chunk reference</span>,
      with a litte adaptation.
      <div class="chunk" name="weave inline chunk" export>
        function weaveInlineChunk(chunk) {
          /* Create unwoven span */
          var unwoven = document.createElement("span");
          unwoven.setAttribute("class", "unwoven");
          unwoven.setAttribute("hidden", true);
          unwoven.innerHTML = chunk.innerHTML;

          <span class="chunkref">create head for inline chunk</span>

          <span class="chunkref">create code for inline chunk</span>

          /* Replace HTML */
          chunk.innerHTML = null;
          chunk.appendChild(chunkHead);
          chunk.appendChild(code);
          chunk.appendChild(unwoven);
        }
      </div>
    </p>

    <h3>Weaving Block Chunk</h3>
    <p>
      Finally, consider block chunk. Almost the same as inline chunk, block chunk
      should be displayed in the format
      <pre><code>
        &lt;span class="block-chunk-head"&gt;⟨chunk name⟩≡&lt;/span&gt;
        &lt;pre&gt;&lt;code&gt;... code block ...&lt;/code&gt;&lt;/pre&gt;
      </code></pre>
      within the original <code>&lt;div class="chunk"&gt;</code> element.
      But, we add a link to the head, clicking which will tangle the chunk.
      Thus, the head span turns into
      <pre><code>
        ⟨&lt;a onclick="tangle(chunkname)"&gt;chunkname&lt;/a&gt;⟩≡
      </code></pre>
      For the tangle link, we have:
      <div class="chunk" name="chunk head span for block chunk">
        /* Create chunk head span */
        var tangleLink = document.createElement("a");
        var chunkName = chunk.getAttribute("name");
        tangleLink.setAttribute("href", "javascript:void(0)");
        tangleLink.setAttribute("onclick", `tangle('${chunkName}')`);
        tangleLink.innerHTML = chunkName;
      </div>
      Then, we create the head and append everything in order.
      <div class="chunk" name="chunk head span for block chunk">
        var chunkHead = document.createElement("span");
        chunkHead.setAttribute("class", "block-chunk-head");
        chunkHead.append(document.createTextNode("⟨"));
        chunkHead.append(tangleLink);
        chunkHead.append(document.createTextNode("⟩≡"));
      </div>
      The unwoven now becomes a <code>div</code> element. So, the code for weaving
      block chunk simply an adaptation of <span class="chunkref">weave inline chunk</span>.
      <div class="chunk" name="weave block chunk" export>
        function weaveBlockChunk(chunk) {
          /* Create unwoven span */
          var unwoven = document.createElement("div");
          unwoven.setAttribute("class", "unwoven");
          unwoven.setAttribute("hidden", true);
          unwoven.innerHTML = chunk.innerHTML;

          <span class="chunkref">chunk head span for block chunk</span>

          /* Create pre */
          var pre = document.createElement("pre");
          var code = document.createElement("code");
          code.innerHTML = chunk.innerHTML;
          pre.appendChild(code);

          /* Replace HTML */
          chunk.innerHTML = null;
          chunk.appendChild(chunkHead);
          chunk.appendChild(pre);
          chunk.appendChild(unwoven);
        }
      </div> 
    </p>

    <h3>Weave Chunks</h3>

    <h3>Weave All</h3>
    Now, we have had the all the functions for weaving. The order of weaving
    chunk references and chunks is irrelevant. So,
    <div class="chunk" name="weave all" export>
      function weave() {
        <span class="chunkref">weave chunk references</span>
        <span class="chunkref">weave chunks</span>
      }
    </div>
    Weaving chunk references is straight forward. We use a stupid loop to
    implement it.
    <div class="chunk" name="weave chunk references">
      /* Weave chunk references */
      var chunkRefs = document.getElementsByClassName("chunkref");
      for (var i = 0; i < chunkRefs.length; i++) {
        weaveChunkRef(chunkRefs[i]);
      }
    </div>
    Weaving chunks is a little more complicated, since chunks can be inline
    (a <code>span</code>) or block (a <code>div</code>).
    <div class="chunk" name="weave chunks">
      /* Weave chunks */
      var chunks = document.getElementsByClassName("chunk");
      for (var i = 0; i < chunks.length; i++) {
        var chunk = chunks[i];
        if (chunk.tagName == "SPAN") {
          weaveInlineChunk(chunk);
        } else if (chunk.tagName == "DIV") {
          weaveBlockChunk(chunk);
        } else {
          throw new Error("Unknown chunk type: " + chunk.tagName);
        }
      }
    </div>

    <h2>Tangling</h2>
    <p>
      We tangle a chunk by calling <code>tangle(chunkName)</code> function, where
      <code>chunkName</code> is a string.

      This function first creates an HTML element as the environment for wrapping
      the tangled code. Usually a <code>pre</code> element.

      Then, we collect all chunks that have the name <code>chunkName</code>.
      As stated in a <a href="#share-chunk-name">previous section</a>, there can be
      multiple chunks with the same name.
    </p>

  </body>
</html>
